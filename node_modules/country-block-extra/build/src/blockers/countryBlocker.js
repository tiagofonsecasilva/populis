"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const geoip = require("geoip-lite");
const isIpPrivate = require("private-ip");
const blocker_1 = require("./blocker");
/**
 * Express middleware to block either based on country or (optionally) on Tor access.
 */
class CountryBlocker extends blocker_1.Blocker {
    /**
     * @param {ICountryBlockerConfig} config  Configuration to use, shared access.
     */
    constructor(config) {
        super(config);
        this.config = config;
    }
    /**
     * The route function of this middleware, to be used in the Express instance.
     * @param {e.Request} req  Request to intercept and check.
     * @param {e.Response} res  Response to use for rejection, if necessary.
     * @param {e.NextFunction} next  Next function to call if rejection ddidn't happen.
     * @returns {Promise<void>}  Completes one the checks have been executed.
     */
    check(req, res, next) {
        return __awaiter(this, void 0, void 0, function* () {
            if (isIpPrivate(req.ip)) {
                next();
                return;
            }
            const geo = geoip.lookup(req.ip);
            if (!geo) {
                if (this.config.lenient) {
                    next();
                }
                else {
                    this.reject(req, res, `geo information lookup for ${req.ip} yielded nothing`);
                }
                return;
            }
            if (-1 !== this.config.blockedCountries.indexOf(geo.country.toLowerCase())) {
                this.reject(req, res, `blocked ${req.ip} because of country '${geo.country}'`);
                return;
            }
            next();
        });
    }
}
exports.CountryBlocker = CountryBlocker;
//# sourceMappingURL=countryBlocker.js.map