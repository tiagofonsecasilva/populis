"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const dns = require("dns");
const events_1 = require("events");
const HttpStatus = require("http-status");
/** Name of event fired on blocking. Yields a reason string and the original request. */
exports.EVENT_BLOCKED = "blocked";
/**
 * Express middleware to block either based on country or (optionally) on Tor access.
 */
class Blocker extends events_1.EventEmitter {
    /**
     * @param {IBlockerConfig} config  Base configuration to use, shared access.
     */
    constructor(config) {
        super();
        this.config = config;
    }
    /**
     * The route function of this middleware, to be used in the Express instance and overridden.
     * Will always block, unless the lenient flag in the configuration is set.
     * @param {e.Request} req  Request to intercept and check.
     * @param {e.Response} res  Response to use for rejection, if necessary.
     * @param {e.NextFunction} next  Next function to call if rejection ddidn't happen.
     * @returns {Promise<void>}  Completes one the checks have been executed.
     */
    check(req, res, next) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.config.lenient) {
                next();
            }
            else {
                this.reject(req, res, "somehow happen to use the blocker base class");
            }
        });
    }
    /**
     * Rejection point. Sends the configured status code and ends the response.
     * Inherited classes might override this for different behavior.
     * @param {e.Request} req  The request going to be rejected.
     * @param {e.Response} res  Response where to send the status code back to.
     * @param {string} reason  Reason for the rejection.
     */
    reject(req, res, reason) {
        this.emit(exports.EVENT_BLOCKED, reason, req);
        const statusCode = this.config.statusCode ? this.config.statusCode : HttpStatus.UNAVAILABLE_FOR_LEGAL_REASONS;
        res.sendStatus(statusCode);
        res.end();
    }
}
exports.Blocker = Blocker;
/**
 * DNS lookup, asynchronized.
 * @param {string} hostname  Host name to look up.s
 * @param {number} family  IP address family, either 4 or 6.
 * @returns Yields the IP address string, or undefined on lookup failure.
 */
function dnsLookup(hostname, family = 4) {
    return new Promise((resolve) => {
        dns.lookup(hostname, { family }, (err, address) => {
            if (err) {
                resolve(undefined);
            }
            else {
                resolve(address);
            }
        });
    });
}
exports.dnsLookup = dnsLookup;
//# sourceMappingURL=blocker.js.map